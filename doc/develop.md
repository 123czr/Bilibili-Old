## 代码贡献指南
---
### 开发环境
1. 安装[Visual Studio Code](https://code.visualstudio.com/)，[Git](https://git-scm.com/)，[Node.js](https://nodejs.org/en/)。
2. Fork仓库然后克隆到本地，Git操作可直接在VSCode中交互完成。
3. 安装TypeScript
```
npm install -g typescript
```

---
### 代码编辑
项目源代码全部位于src目录下，使用Typescript进行开发。需要注意的是脚本源码其实分为3部分：src主目录下index.ts文件，src及其子目录下所有`.ts`文件，dist目录下托管的B站原生js文件。  
1. index.ts：这是脚本的入口，标准的用户脚本文件。  
上下文环境为Tampermonkey提供的沙盒，可以访问DOM，但访问页面顶层对象需要使用`unsafeWindow`，可以直接使用高级API。  
本部分作为第二部分的入口和引导，代码量极少且不实现任何具体功能，所以很少需要修改。
2. src及其子目录下所有`.ts`文件：本项目称之为“模块”。  
模块可位于src及其子目录的任何位置，本脚本索引模块只使用文件名(包括拓展名)，与所在目录无关，所以模块间不允许重名！  
上下文环境为就是页面上下文，可以直接访问顶层对象`window`，只能间接使用高级API——封装于全局对象`GM`中。  
另有全局对象`API`作为`window`替代，模块的互通数据都请通过`API`对象，原则上不需去污染`window`。  
尽量一个功能一个模块以便维护，模块可以直接实现功能，也可以作为其他功能的“库”：
直接实现功能的模块需要自己在相应的入口里主动使用API.importModule([模块文件名])方法载入运行，入口可以在rewrite.ts(重写相关功能入口)、src/match目录下ts文件(页面区分入口)、vector.ts(重写外的全局入口)，或者其他任何必定运行的ts文件中。  
作为“库”使用，可以将需要暴露的数据放在`API`对象，并在json/apply.json文件中关联好数据：模块名。“库”不必主动载入运行，脚本会在用到对应数据时自动载入运行。  
另外文件名以`[run]`开头的模块是“自运行模块”，全局默认运行，可作为免于添加入口代码的一种方案。
3. dist目录下托管的B站原生js文件。  
这些文件的存在是因为有些功能无法用常规手段修复，只能直接修复并托管相关代码。  
本部分全部是js代码，而且经过高度混淆压缩，不会被打包进脚本中，需要使用其他手段使用，所幸一般不需要修改。

项目中还用到了一些非代码文件，分类存放于CSS，HTML，image，json等目录下，其中css，html以及部分json文件与“模块”使用类似的方式打包进了脚本，只是因为并非代码文件，切莫使用API.importModule([模块文件名])方法载入运行！取而代之的是使用API.getModule([模块文件名])方法以字符串形式获取——json文件会直接代为格式化为对象，无需再次格式化！  
脚本元数据位于json/meta.json，不会打包进脚本，修改脚本版本号等操作位于这里。  
脚本外部依赖位于json/resource.json，不会打包进脚本，可以使用高级API`GM_getResourceText`/`GM_getResourceURL`获取。

修改完成后可以使用运行`clear`（已设置为默认任务，使用快捷键`Ctrl` + `Shift` + `B`直接运行。）任务完成编译、合成、清理临时文件的操作，最后提交修改即可。

---
### 全局对象
“模块”中可以像使用`window`一样直接使用一些预定义好的对象：
1. API：作为类似于`window`的存在，是模块间交流数据的基础。
2. GM：高级API对象，只申请了目前用到的，需要添加的话请在json/meta.json中声明，然后在index.ts中封装好。
3. debug：console的部分再封装，添加了时间戳。
4. toast：浮动通知组件。
5. xhr：XMLHttpRequest的Promise封装，同时还封装了高级API`GM_xmlhttpRequest`为Promise。
6. config：用户设置数据，来自API.registerSetting方法注册的设置项，存储形式key：value。

其他内置的或由模块添加数据都位于API对象上，已完善了类型声明，可以在VSCode中自动获取详细的代码提示，往API上暴露数据时也请一并完善类型声明。

---
### 代码规范
1. 模块主体代码需要放在一个自运行函数或命名空间中以免污染顶层对象。
2. 请使用原生的ts/js语法，不要引入jQuery等直接改变语法的外部库，或者自行使用原生ts/js封装“库”，就像xhr.ts封装XMLHttpRequest那样。
3. ESNext的新特性只要不报错就可以使用，但不要为了强行使用引入任何Polyfill。
4. 不要求代码风格统一，但请一定要完善类型声明，以便其他贡献者使用相关数据。

---
### 合并请求
提交完推送到你的远程仓库，然后往`master`分支发起合并请求即可。