# 代码贡献指南
### 开发环境
- [Visual Studio Code](https://code.visualstudio.com/).
- [Node.js](https://nodejs.org/).
- [Google Chrome](https://www.google.com/chrome/).

### TypeScript
- 既已manifest V3，何妨ESNext，任何最新特性放开手用就是.
- 引入[esbuild](https://esbuild.github.io/)以突破各组件对ESNext module标准支持差异限制.

### 目录
- `src`：源代码及资源.
- `dist`：【加载已解压的扩展程序】.

### 开发
1. 拓展各组件都有自己的目录，使用ESNext标准开发。
2. 编译任务已设为VSCode默认生成任务，也可以指定运行`npm: esbuild`任务，或者以npm方式运行`esbuild`脚本.
3. 输出目录为dist，chrome开启开发者模式后以【加载已解压的扩展程序】载入该目录即可进行调试。

### Pull Request
可以直接向主分支`master`发起pr，有志于长期合作的也可以像仓库所有者申请合作者权限。

### 拓展逻辑
拓展主要分为后台脚本、选项页面、弹出页面、内容脚本以及注入进页面的降级为普通脚本`userscript`组成，各部分之间通过消息传递机制进行沟通。
#### 后台脚本
Manifest V3取消了常驻的后台页面，改为基于Server Worker，这带来了一些列限制需要特别注意：
   1. 后台脚本无法使用任何涉及DOM的运行环境，包括通常的顶层上下文`window`。
   2. 后台脚本有5分钟强制休眠的机制，任何全局变量都面临丢失的风险，所以原则上不要使用任何全局变量。
   3. 后台脚本禁止使用XMLHttpRequest，访问网络只能通过fetch。
   4. ~~后台脚本只支持最基础的 ESNext module，不能将json作为模块导入。~~ （引入[esbuild](https://esbuild.github.io)后已无妨）

新标准是铁了心让后台脚本无法主动执行任何业务逻辑，成为真真正正的“后台”脚本，充当一个在后台为扩展其他部分服务的角色（残废*🤣）。主要是通过`storage`和消息传递机制处理其他部分（主要是内容脚本和`userscript`）无权进行的操作并将结果返还回去。
#### 选项页面和弹出页面
选项页面和弹出页面在新标准中没有什么大的改动，不过这两者都是与用户交互的，一个作为扩展设置调整界面，一个提供了一些针对当前页面可执行的操作，通过消息机制将用户的选择发送给内容脚本和`userscript`处理。
#### 内容脚本
内容脚本即注入到标签页（独立上下文）中脚本，在新标准中也有了新的注意事项：
   1. 严格的CSP策略导致内容脚本无法以任何手段突破独立上下文环境的封锁，包括但不限于`eval`、`setTimeout/setInterval`和`new Function`都无法使用，也不允许往页面中添加内联或拓展外源的script元素。
   2. 内容脚本无法以任何手段及时获取到页面上下文中的任何JavaScript变量，反之亦然，就算通过消息机制传递任何不可克隆的对象都被禁止。
   3. 内容脚本往DOM上自定义的非原生属性对页面上下文不可见，反之亦然。
   4. ~~内容脚本不支持静态的 ESNext module 你敢信！~~ （引入[esbuild](https://esbuild.github.io)后已无妨）
   5. 内容脚本不支持`customElements`你敢信！

以上限制基本锁死了内容脚本能够对页面进行的修改，除非你不打算与页面上下文有任何交互，也不管不顾页面上下文任何看待你对于DOM的修改，否则用来承载对页面的针对性修改工作是完全不称职的。（残废*🤣🤣）只能当作消息传递的中间人：对于来自`userscript`的请求消息，内容脚本有权处理就处理，无权处理就打包发送给后台脚本再等待后台脚本返回处理结果打包发还给`userscript`；同时选项页面和弹出页面有任何消息进行打包传递。
#### `userscript`
以script标签直接关联到拓展内部的脚本，上下文回到了页面，但也彻底失去了作为拓展一部分的任何特权，只能以消息传递机制向内容脚本申请自己的诉求。  
任何实际的对页面执行的业务代码实际上都是`usesrcript`负责的（为了区分在每个目录中都以`userscript.ts`命名）。使用标准的 ESNext module 语法编写，实际业务逻辑进一步细分到每一个具体的业务模块及依赖模块中。
