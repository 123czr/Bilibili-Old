## 源码说明
---
### 环境依赖
- [Visual Studio Code](https://code.visualstudio.com/)
- [Node.js](https://nodejs.org/)
- [TypeScript](https://www.typescriptlang.org/)
- [Git](https://git-scm.com/)

---
### 代码修改
本项目由脚本本体以及资源模块组成，分别由不同任务进行编译。
   - 脚本本体：index.ts及./index子目录下所有文件构成，运行任务`build`编译并合并为根目录下的main.user.js(脚本本体)。
      - 脚本本体只提供基本项目依赖，大部分功能都由模块负责实现，所以一般不需要修复主体相关代码。
      - 编译脚本主体必须在模块完成修改并提交后再进行，以便生成模块修改信息(记录在根目录resource.json中)。
      - 修改脚本版本号等元数据在根目录meta.json里完成。
      - 在脚本本体中添加了新功能(函数、对象等)请在../module/global.d.ts中补充声明信息，以便作为依赖在模块中使用。
      - main.user.js和resource.json的提交意味着模块修改生效，这两个文件不能与其他模块共用提交。
   - 资源模块：../module子目录下所有文件，运行默认任务`tsc-module`编译为根目录.\dist下对应js文件，一个js文件就是一个模块。
      - 模块ts源码全部放在../module子目录下，可以在其下新建子目录以进行归档，甚至多层子目录。
      - 本项目只以文件名(含拓展名)索引模块，如：ui.js，只要在../module子目录下，无论多深都能索引到。
      - 基于此索引机制，**所有**模块不允许重名！
      - 外部(在线)资源也可以作为本脚本的模块，这种请添加在./index/config.ts子目录顶部的resource数组中。
      - 外部资源与模块索引机制完全一样，以链接文件名(含拓展名)索引，所以也不许重名。
      - CSS、json、HTML等非代码资源请放在跟目录下对应子目录中，同样以文件名(含拓展名，json例外要去掉拓展名)索引，同样不允许重名。

本项目将一个功能单独为一个模块，功能代码量很大时还可以再拆分成更多小模块，还可以归档到专门的子目录中。然后使用API上的方法载入或访问，如API.importModule根据文件名索引获取，又获取根据根目录./json/apply.json中的对应关系自动加载依赖。总之，想拆成几个模块就拆成几个，则么方便怎么来。

---
### 全局变量
脚本主体提供了一系列“开箱即用”的数据供模块使用，这些数据可以在模块中像使用原生数据(比如window)一样使用，本项目称之为“全局变量”。
- API: 这是模块中类似于顶层变量window一样的存在，大部分函数及变量都以属性的方式挂载在上面。
   - 比如API.importModule函数，这是本项目载入运行模块的基本方法，API.importModule("ui.js")即可索引并载入运行名为ui.ts的模块。
   - 访问一个不存在与API上的对象等同于访问window下的同名属性，如API.console等于window.console，这种用法可以安全的访问页面写在window上的信息，如果目标不存在window上也不会报错，只会返回undefined。
   - 模块也可以将要提供给其他模块用的数据以属性的方式挂载在API对象上，然后在根目录./json/apply.json中添加对应关系，其他模块就可以使用该数据。
   - 访问API上一个由其他模块提供的数据，但供体模块还没运行也能正常获取，脚本会根据./json/apply.json中对应关系运行同步依赖模块然后返回数据，省区检查依赖的繁琐。
- GM: 高级API GM_xmlhttpRequest等的封装，以属性方式提供。
   - 目前只用到并封装了GM_xmlhttpRequest、GM_getValue等少部分。
   - 如果添加新API需求，请在根目录meta.json添加元素据声明并在./index/API.ts中以相同方式封装，最后别忘了在../module/global.d.ts补充声明信息给模块使用。
- xhr: XMLHttpRequest的封装了，接收一个包含XMLHttpRequest配置信息的对象作为参数以发起ajax请求。
   - 可以按需添加所有XMLHttpRequest支持的配置，以可以只添加一条url信息，如`xhr({ url: "https://..." })`，此时返回一个Promise，其resolve为XMLHttpRequest.response。
   - 若添加async属性为true，则ajax将以同步的方式发送阻塞并等待请求返回，但并不推荐这样使用。
   - xhr同时还作为对象存在，其GM属性将调用高级API GM_xmlhttpRequest发送跨域请求，同样以Promise形式托管结果。
- debug: console的封装，格式化并添加了时间戳信息。
- toast: toastr，可以看作debug的浮动通知版本。
- config: 脚本设置数据，记录了功能启用与否等信息。
- importModule: 即API.importModule，鉴于导入模块可能是一个过于频繁的操作额外单独了出来。

各种“全局变量”的用法VSCode会提供更详尽的提示，由其是API上的属性，只要存在就可以放心使用而不用管其实现在那个模块中，脚本运行时会自动根据根目录./json/apply.json中的对应关系自动补充依赖。

---
### 原生脚本
模块编译会在根目录dist目录下生成js文件，原则上直接对这些js文件的修改是无效的，但也有例外，那些是托管的来自B站的原生js脚本，其中部分功能面临失效，传统编程方法很难修复，只能修改源代码并托管于此，分别是：
- bilibiliPlayer.js：旧版播放器脚本主体脚本
- video.js：旧版播放器脚本脚本
- comment.js：旧版评论区脚本

这些混淆压缩过的js脚本无法还原为ts文件，甚至原本也就不是ts文件，只能直接修改js文件。

---
### 使用资源
资源其实是模块的另一种形式，存取方式完全同模块，只不过不可以作为代码执行，分别放在根目录下对应类别名称中：
- CSS：css样式文件，其代码格式与ts/js迥异，直接写在代码中不利于阅读，推荐独立为文件，并使用API.getModule([文件名(含拓展名)])的方式获取对应字符串。
- HTML：旧版网页框架文件，使用方式同CSS，基本上不需要修改的存在。
- Json：json数据，与前两者不同，在本脚本中直接以对象形式存储，免去从字符串转化的步骤，使用方法为高级API的封装版本，如GM.getValue，**不需要拓展名**。(由于json不支持内联注释，现将已有的json说明如下)
   - apply.json：属性与模块名对照表，脚本根据此表关联API上的属性与对应模块依赖，在用到时自动载入。
   - bug.json：新版页面在window上写入的干扰数据，可能会造成旧版页面出错，将在重写页面时全部清空。
   - protobuf.json：protobufjs反射依赖的json数据，主要用于解码新版弹幕。
   - videoSort.json：B站新增/修改的分区表，旧版页面不能识别这些分区，由脚本代为修复。
- image：虽然更推荐使用svg描述图片，但有些还是只能以文件的形式存在，这类二进制文件不方便存储到本地，请直接在线访问本仓库对应的资源链接，也可以通过cdn如jsdelivr代理。

---
### 本地调试
脚本本体从网络下载模块缓存到本地，这意味着模块调试变得有点困难，一些问题代码不确定也不敢推送到远程仓库。  
为了解决这个问题，本项目支持从本地磁盘更新模块文件：设置 > 通用 > 安装本地模块。  
点击“选择”即可前往本地文件选择，支持多选，可以将编译出的js文件、css、json、html资源导入到脚本中即可进行调试。  
同样以文件名为索引，同名覆盖。  
添加新功能同样可以用此方法添加所有依赖进行测试。

---
### 编译发布
对于代码的修改基本都是对于模块的修改，修改后运行任务`module`编译会js文件，最后git commit提交。  
确认要推送到远程仓库时，运行`build`的任务，将记录提交信息到根目录resource.json文件中，提交本文件即完成一次修改。  
一般不涉及脚本主体的修改无需增加版本号，脚本的更新机制会自动根据resource.json中信息定期检查模块更新。  
如果运行`build`的任务一同编译的还有新的脚本主体main.user.js，说明此次更新动到了脚本主体，这是需要前往根目录meta.json中增加版本号，然后再运行一次`build`的任务重新生成main.user.js和resource.json，提交这两个文件即完成一次涉及脚本本体的修改。  
如果需要推送贡献到本仓库，可以将提交推送到自己的fork然后发起Pull requests即可。