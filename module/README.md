## 模块释明
---
### 所谓模块
本项目所称之为的模块本质上就是一个普通的js脚本，最普通的能在网页中直接加载运行的那种，既不是ES6概念下的模块，也不是各种第三方库中的模块。当然这里指的是js对应的ts文件，ts作为js的超集与VSCode是完美搭配。  
模块的功能是将代码尽可能地拆分为一个个小文件以便于更新与维护，由于用户脚本运行环境特殊，一般概念的模块结构难以完美适用，把所有代码都放在一个文件中又过于笨重。当一个项目大到一定程度时，模块化几乎是必然的选择，然而究竟如何模块化？
1. 使用ES6标准的模块。这本来是理所当然的选择，但是很可惜找不到传递脚本管理器提供的高级API给模块的方法。ES6模块是运行在独立的上下文环境中的，官方也不提供类似与函数传递之类的传递变量的方法，也就无法在模块中使用那些高级API。这是致命的，本脚本严重依赖使用高级API，总不能把所有用到高级API的地方都写在脚本主体中，那样就背离了模块化的初衷，这种夹生的模块化根本没有意义。
2. 借助webpack等打包工具编译ES6模块。前端打包工具确实很方便，能以模块的方式更新和维护脚本，最后打包成一个文件就好。由于最后还是打包为一个文件，本质上ES6模块只是形式，本质上仍在一个文件中，上下文环境也一样，这样就解决了不能使用高级API的问题。唯一的问题是打包压缩过的代码违反了[Greasy Fork 有关发布脚本的规则](https://greasyfork.org/zh-CN/help/code-rules)的规定，鉴于大多数人还是习惯于在Greasy Fork安装脚本，只能被迫放弃了。
3. 使用`@require`方法。脚本管理器提供的库依赖加载方案，把模块当成库一样使用也不是不可以，库和脚本本体也是在同一个上下文环境中运行的，不必担心不能使用高级API的问题。只是这种依赖是强制运行的，而本项目的很多功能是由专门针对的，不必全部默认运行，那样只会造成资源的浪费，不符合模块能够按需加载的要求。
4. 使用eval?！非法工具！
5. 使用Function构造函数。用法同eval但运行在独立的上下文环境中，不用担心安全问题。支持以类似函数参数的形式传递数据给模块，解决了在模块中使用高级API的问题。本质是将在模块作为字符串存储，使用时再用Function载入。唯一的问题是如何存储模块字符串？
   1. 使用`@resource`方法。脚本管理器提供的资源依赖存储方案，本脚本5.x及之前的版本即使用这种方案，而且运行得非常良好，直到……随着模块数量的增多，脚本注入速度显著下降，作为一个基础功能是重写页面的脚本，注入速度下降的体验是致命的，只能另寻他途。
   2. 使用GM_setValue等API。脚本管理其提供的数据存储高级API，类似于`@resource`但是不用提前加载资源，不会影响注入速度，完美贴合本脚本需求。唯一的问题是模块的管理将全权由脚本自己负责，而且初次运行时是一个模块也没有，必须主动去下载，不过只需一次，应该不是特别麻烦。

于是本项目转为使用GM_setValue等高级API作为模块的存储方案，然后封装了构造函数Function作为模块载入的解决方案，特别创立了这种模块解决方案。

---
### 模块规范
本项目的模块本质上普通的js/ts文件，所以像普通js/ts文件那样编写就好，只不过有几点提醒：
1. 模块中可以像使用window那样使用一些脚本主体提供的“全局变量”，当然一旦使用了那就不再是普通js/ts文件了，限制成了本项目专属模块。
2. 模块主体代码需要写再一个自运行函数中，或者使用ts的命名空间，因为VSCode默认所有源文件公用一个命名空间，也就是顶层命令空间。如果不限制一下作用域，就会污染(VSCode会这样认为)顶层变量window，导致一些不能在不同文件中使用相同变量名之类的稀奇古怪的报错警告。
3. 模块间共享数据请通过变量API，而不是去污染顶层对象window，前者就是作为后者的替代而存在的。污染window是一种不优雅的行为，除非实在没办法。本脚本重写页面功能深受B站原生脚本各种污染window困扰，所以对这一点尤为深恶痛绝！（感受bug.json中的深深怨念 ಥ_ಥ）
4. 模块请尽量遵循按需运行的原则，做到不需要运行就别运行，可以将功能引导代码写在一个专门的模块中，而具体实现拆分进一个个小模块中，通过API对象交流数据。在apply.json写好数据与模块名称的对应关系还能托管模块依赖，脚本会在用到相关数据时自动执行关联的模块，真正实现按需加载按需运行。

---
### 模块引导
本脚本的核心功能是重写页面，重写页面是一个极具破坏性的操作，一般的模块都必须在重写页面之后运行，尤其是设计到与DOM互通数据的模块。  
所谓引导即功能的入口，模块是按需运行的，那是被谁需要呢？一个功能有罪基础的判断是否需要运行的代码，本项目称之为引导。  
vector.ts就是负责专门引导各个功能模块的，一般把功能判断和引导代码写在这里就行，如果引导太长可以写在专门的引导模块中，然后再这里引导那个引导。  
rewrite.ts负责重写功能相关的引导，这部分基本上按页面类型固定的，如果某个功能是专门适用于某个重写过的页面的，那就在对应的重写引导比如av.ts中添加引导代码。